# Python 语言程序设计

Python 入门课程

> 本笔记均基于 Python 3x

# 目录（Contents）

* [0. 基本概念]
* [1. Python 基本语法元素]
    * [1.1 程序设计基本方法]
    * [1.2 Python 开发环境配置]
    * [1.3 实例1: 温度转换]
    * [1.4 Python 程序语法元素分析]
* [2. Python 基本图形绘制]
    * [2.1 深入理解 Python 语言]
    * [2.2 实例2: Python 蟒蛇绘制]
    * [2.3 模块1: turtle 库的使用]
    * [2.4 turtle 程序语法元素分析]
* [3. 基本数据类型]
    * [3.1 数字类型及操作]
    * [3.2 实例3: 天天向上的力量]
    * [3.3 字符串类型及操作]
    * [3.4 模块2: time 库的使用]
    * [3.5 实例4: 文本进度条]
* [4. 程序的控制结构]
    * [4.1 程序的分支结构]
    * [4.2 实例5: 身体质量指数 BMI]
    * [4.3 程序的循环结构]
    * [4.4 模块3: random 库的使用]
    * [4.5 实例6: 圆周率的计算]
* [5. 函数和代码复用]
    * [5.1 函数的定义与使用]
    * [5.2 实例7: 七段数码管绘制]
    * [5.3 代码复用与函数递归]
    * [5.4 模块4: PyInstaller 库的使用]
    * [5.5 实例8: 科赫雪花小包裹]
* [6. 组合数据类型]
    * [6.1 集合类型及操作]
    * [6.2 序列类型及操作]
    * [6.3 实例9: 基本统计值计算]
    * [6.4 字典类型及操作]
    * [6.5 模块5: jieba 库的使用]
    * [6.6 实例10: 文本词频统计]
* [7. 文件和数据格式化]
    * [7.1 文件的使用]
    * [7.2 实例11: 自动轨迹绘制]
    * [7.3 一维数据的格式化和处理]
    * [7.4 二维数据的格式化和处理]
    * [7.5 模块6: wordcloud 库的使用]
    * [7.6 实例12: 政府工作报告词云]
* [8. 程序设计方法学]
    * [8.1 实例13: 体育竞技分析]
    * [8.2 Python 程序设计思维]
    * [8.3 Python 第三方库安装]
    * [8.4 模块7: os 库的使用]
    * [8.5 实例14: 第三方库安装脚本]
* [9. Python 计算生态概览]
    * [9.1 从数据处理到人工智能]
    * [9.2 实例15: 霍兰德人格分析雷达图]
    * [9.3 从 Web 解析到网络空间]
    * [9.4 从人机交互到艺术设计]
    * [9.5 实例16: 玫瑰花绘制]

## 0. 基本概念

**程序设计语言**

* **程序设计语言**是一种用于交互（交流）的人造语言
* **程序设计语言**亦称**编程语言**，程序设计的具体实现方式
* 编程语言相较于自然语言更简单、更严谨、更精确
* 编程语言用于人类和计算机之间的交互

**源代码**：采用某种编程语言编写的计算机程序，人类可读

**目标代码**：计算机可直接执行，人类不可读（专家除外）

**编译**：将源代码**一次性转换**成目标代码的过程（可类比为一次性翻译）

源代码 -> 编译器 -> 目标代码

**解释**：将源代码**逐条转换**成目标代码**同时逐条运行**的过程（可类比为同声传译）

源代码 -> 解释器 -> 执行

根据执行的方式不同，编程语言可分为两种类型

1. **静态语言**：编译执行。优化更充分，程序运行速度更快。如 c/c++、java 等。
2. **脚本语言**：解释执行。维护更灵活，跨系统能力通用性更强。如 Python、JavaScript、PHP 等。

## 1. Python 基本语法元素

> 通过经典实例（实例1）尝试 Python 编程，掌握 Python 基本语法元素，能够编写 10 行代码。

### 1.1 程序设计基本方法

IPO

* 1 input 输入 - 文件、网络、交互（控制台、交互界面等）、内部参数等
* 1 Process 处理 - 程序逻辑
* 1 Output 输出 - 文件、网络、交互（控制台、交互界面等）、内部参数等

程序设计的步骤

1. 分析问题 分析需要解决的问题
2. 规划边界 设计 IPO
3. 设计算法 设计程序的算法（解决问题的方法）
4. 编写程序 编写程序本身
5. 调试测试 保证程序的正确运行
6. 升级维护 适应问题变化

Python 的两种编程方式

1. **交互式**：对输入的语句即时运行结果，适合语法练习
2. **文件式**：批量执行一组语句并运行结果，编程的主要方式

### 1.2 Python 开发环境配置

各种平台使用 [Anaconda](https://www.anaconda.com/download/#macos) 搭建 Python 开发环境，可参考 Timothy 老师的 [搭建开发环境，跨平台原理](http://sa.mentorx.net/course/54/task/321/show)

### 1.3 实例1: 温度转换

```py
# TempConvert.py
tempStr = import("请输入带有符号的温度值：")
if tempStr[-1] in ['F', 'f']:
    C = (eval(tempStr[0:-1]) - 32)/1.8
    print("转换后的温度是{:.2f}C".format(C))
elif tempStr[-1] in ['C', 'fc']:
    F = 1.8*eval(tempStr[0:-1]) + 32
    print("转换后的温度是{:.2f}F".format(F))
else
    print("输入格式错误")
```

### 1.4 Python 程序语法元素分析

#### 1.4.1 程序的格式框架

1. **缩进**：一行代码开始前的空白区域（**通常一个缩进可以是 4 个空格或 1 个 tab**），表达程序的格式框架  
  1.1 **严格明确**：Python 中缩进是语法的一部分，缩进不正确会导致运行错误  
  1.2 **所属关系**：表达代码间包含和层次的唯一方式  
  1.3 **长度一致**：程序内需保持一致
2. **注释**：用于提高代码可读性的说明性文字，不会执行
  1.1 **单行注释**：以 `#` 开头，其后整行均为注释内容 `# 单行注释`
  1.2 **多行注释**：以 `'''` 开头和结尾，两个 `‘'''` 之间的内容均为注释（其实为多行字符串，Python 没有提供多行注释，但如果字符串未赋予任何变量则不会执行，可作为注释使用）

    ```py
    # 这是一个单行注释

    '''
    这是一个多行注释
    这里的内容均为注释
    '''
    ```

#### 1.4.2 命名与保留字

1. **变量**：用来保存和表示数据的占位符  
  1.1 **标识符**：变量采用标识符（名字）来表示，关联标识符的过程叫**命名**  
  1.2 **赋值符号（`=`）**：可以使用 赋值符号向变量赋值或修改值（赋值符号与数学中的等号不同）, 如`str = "abc"`：将字符串 `"abc"` 赋值给 `str`
    > **命名**：关联标识符的过程  
    > 命名的规则：大小写字母、数字、下划线和汉字（不推荐）等字符及字符的组合  
    > 注意：大小写敏感，数字不能作为开头，不能与**保留字**相同
2. **[保留字]**：也叫 **关键字**，是被编程语言定义并保留使用的标识符

    ```text
    False      await      else       import     pass
    None       break      except     in         raise
    True       class      finally    is         return
    and        continue   for        lambda     try
    as         def        from       nonlocal   while
    assert     del        global     not        with
    async      elif       if         or         yield
    ```

#### 1.4.3 数据类型: 供计算机程序理解的数据形式

##### 1.4.3.1 **字符串**：由 0 个或多个字符组成的有序字符序列

##### 1.4.3.2 **数字类型**：**整数** 和 **浮点数**

1. **整数**：数学中的整数，包含正数和负数
2. **浮点数**：数学中的实数（带小数部分的数字），包含正数和负数

```py
# 数字类型的使用
int = 1 # 整数
float = 1.0 # 浮点数
```

##### 1.4.3.3 **列表类型**：由 0 个或多个数据组成的有序字符序列  

1. 列表使用 `[]` 表示，使用逗号（`,`）分隔各个元素
2. 使用保留字 `in` 判断一个元素是否在列表中

```py
# 列表的使用
list = ['a', 'A']

'A' in list # True A 在 list 中
'b' in list # False b 不在 list 中
```

#### 1.4.4 语句与函数

##### 1.4.4.1 **赋值语句**：由赋值符号（`=`）构成的一行语句

1. 赋值语句用于给变量赋予新的数据值  
2. 赋值语句右侧的数据类型同时作用于变量

```py
# 赋值语句
a = 'a'
int = 1
float = 1.0
```

##### 1.4.4.2 **分支语句**：由判断条件决定程序的运行方向的语句

1. Python 中使用保留字 `if`、`elif`、`else` 构成条件判断的分支结果

```py
# 分支语句 if elif else

# 语法
if (<判断语句1>):
    # 如果 <判断语句1> 放回 True 则执行此语句快
elif <判断语句2>: # 可以有 0 个或多个 elif 分支
    # 如果 <判断语句2> 放回 True 则执行此语句快
else:
    # 如果所有判断语句都返回 False 则执行此语句快（此部分可省略）
```

##### 1.4.4.3 **函数**：根据输入参数产生不同输出的功能过程

1. 类似数学中的函数 y = f(x)

#### 1.4.5 Python 程序的输入输出

* `input()` 以字符串形式接收控制台输入
* `print()` 以字符串形式向控制台输出
* `eval()` 去掉参数的最外侧引号并执行余下的语句

## 2. Python 基本图形绘制

> 通过经典实例（实例2）尝试 Python 编程，理解 Python 库的使用方法，能够进行基本图形编程。

### 2.1 深入理解 Python 语言

Python 语言的特点

1. 通用
2. 脚本语言
3. 开源
4. 跨平台
5. 多模型

## 3. 基本数据类型

> 掌握数字类型（整数、浮点数和复数）和字符串类型的使用方法，掌握 time 库，能够操作文本并处理时间。

### 3.1 数字类型及操作

#### 3.1.1 整数类型

* 与数学中的整数一致
* 有正负
* 无取值范围限制

整数的 4 种进制表示：

1. 十进制：1010，99
2. 二进制（以 `0b` 或 `0B` 开头）：0b010
3. 八进制（以 `0o` 或 `0O` 开头）：0o123
4. 十六进制（以 `0x` 或 `0X` 开头）：0x9a

#### 3.1.2 浮点数类型

* 与数学中的实数一致
* 取值范围和小数精度都有限制（影响不大）
* 取值范围数量级：-10^308 ~ 10^308
* 精度数量级：10^-16

> 注意：浮点数间计算存在不确定尾数（不是 bug，与计算机实现浮点数的机制有关，各种编程语言中都存在）  
> 如：0.1 + 0.2 # 0.30000000000000004  
> 比较两个浮点数相加的结果：  
>
> ```py
> 0.1 + 0.2 == 0.3 # False
> # 使用 round函数 可解决此问题
> # round(数字, 取小数位数) 四舍五入
> round(0.1 + 0.2, 1) == 0.3 # True
> ```

浮点数的科学计数表示：

使用 `e` 或 `E` 作为幂的符，以 10 为集数。  
如：aeb 表示 a*10^b -> 4.3e-3 表示 0.0043

#### 3.1.3 复数类型

与数学中的复数（j）一致（只有 Python 语言提供复数类型）

```python
z = 1+2j
z.real # 获得实部
z.imag # 获得虚部
```

#### 3.1.4 数值运算操作符

一元操作符

| 操作符 | 使用 | 描述 | 示例 | 备注 |
|:-----:|:----:|-----|-----|-----|
| + | +x | （自身） | `+1 # 1` |
| - | -x | 负值 | `-1 # -1` |

二元操作符

| 操作符 | 使用 | 描述 | 示例 | 增强赋值操作符 | 增强赋值操作符示例 | 等价于 | 备注 |
|:-----:|:----:|-----|-----|-----|-----|-----|-----|
| + | x + y | 加 | `1 + 1 # 2` | += | x += y | x = x + y |
| - | x - y | 减 | `2 - 1 # 1` | -= | x -= y | x = x - y |
| * | x * y | 乘 | `2 * 2 # 4` | *= | x *= y | x = x * y |
| / | x / y | 除 | `10 / 3 # 3.3333333333333335` | /= | x /= y | x = x / y | 与大部分编程语言不同，Python 的除法的结果为浮点数（多数编程语言除法结果为整数，相当于 Python 中的整除） |
| // | x // y | 整除 | `10 // 3 # 3` | //= | x //= y | x = x // y |  |
| % | x % y | 余数，模运算 | `10 % 3 # 1` | %= | x %= y | x = x % y |  |
| ** | x ** y | 幂运算 | `2 ** 3 # 8`<br>`4 ** 0.5 # 2（4 开 2 次方）` | **= | x **= y | x = x ** y | 当 y 为小数时做开方运算 |

#### 3.1.5 数值类型的关系

类型间可进行混合运算，生成的结果为“最大”类型

整数 < 浮点数 < 复数

#### 3.1.6 数值运算函数

计算

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| abs(x) | 绝对值 | `abs(-3) # 3` |
| divmod(x, y) | 商余 | `divmod(10, 3) # (3, 1)` | 商余：商和余数<br>示例中结果 3 为 商，1 为余数 |
| abs(x) | 绝对值 | `abs(-3) # 3` |
| pow(x, y[, z]) | 幂余 | `pow(2, 10) # 1024`<br>`pow(2, 10, 100) # 24` | pow(x, y) 为幂运算<br>pow(x, y, z) 为幂余（在特定场景很有用，如求得的值过大时）<br>`[]` 表示该参数是可选的 |
| round(x, d=0) | 四舍五入 | `round(-10.123) # 10`<br>`round(-10.123, 2) # 10.12` | `d` 指定保留的位数，默认值为 0，可省略 |
| min(x1, x2...xn) | 最小值 | `min(5, 3, 10) # 3` | 比较的值的数量不限，可为 2 个或多个 |
| max(x1, x2...xn) | 最大值 | `man(5, 3, 10) # 10` | 比较的值的数量不限，可为 2 个或多个 |

数值转换

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| int(x) | 转换为整数 | `int(1.35) # 1`<br>`int("1.35") # 1` | 将 x 转换为整数并舍弃小数部分<br>x 可以为其它数据类型，如字符串 |
| float(x) | 转换为浮点数 | `float(1) # 1.0`<br>`float("1.32") # 1.32` | 将 x 转换为小数<br>x 可以为其它数据类型，如字符串 |
| complex(x) | 转换为复数 | `float(1) # 1.0`<br>`complex("1") # 1 + 0j` | 将 x 转换为复数<br>x 可以为其它数据类型，如字符串 |

### 3.2 实例3: 天天向上的力量

### 3.3 字符串类型及操作

#### 3.3.1 字符串的表示

**字符串有 2 类 4 中表示**

1. 字符串由一对单引号（`'`）或双引号（`"`）表示（使用 `'` 或 `"` 没有区别），仅表示单行字符串
2. 有一对三单引号（`'''`）或三双引号（`"""`）表示，可表示多行字符串（如果字符串未赋予任何变量则不会执行，可作为注释使用）

* 字符串为字符的有序序列，可对其中的字符进行索引

| | | | | | | | | | | | | |
|-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|反向递减序号：|-12|-11|-10|-9|-8|-7|-6|-5|-4|-3|-2|-1|
|字符串：|请|输|入|带|有|符|号|的|温|度|值|：|
|正向递增序号：|0|1|2|3|4|5|6|7|8|9|10|11|

**字符串的使用**

使用 `[]` 获取字符串的一个或多个字符

1. **索引**：返回字符串中单个字符 `<字符串>[M]`
2. **切片**：返回字符串中的多个字符（子串）`<字符串>[M: N]` 或 `<字符串>[M: N: K]`（`K` 为步长）

```py
# 字符串的使用
str = "请输入带有符号的温度值："

str2 = '''
这是一个多行字符串
第二行
第三行
... ...
'''

# 索引
str[0] # 请
str[-1] # ：

# 切片
str[0:3] # 请输入
str[3:] # 带有符号的温度值：
str[:-3] # 请输入带有符号的温度

# 切片 高级用法
srt[0::2] # '请入有号温值'

# 小技巧 - 逆序
str[::-1] # '：值度温的号符有带入输请'
```

**字符串中的转义符**

1. 转义符表达特定字符的本意 - `\` 表示转义

* `\b` 回退
* `\n` 换行（光标移动到下一行行首）
* `\r` 回车（光标移动到本行首）

```py
"这里有个双引号（\"）" # 这里有个双引号（"）
```

#### 3.3.2 字符串操作符

| 操作符 | 使用 | 描述 | 示例 | 备注 |
|:-----:|:----:|-----|-----|-----|
| + | x + y | 连接 | `'a' + 'b' # 'ab'` |
| * | x * n | 赋值 | `'ab' * 2 # 'abab'` |
| in | x in s | 包含 | `'ab' in 'dabc' # True` | 如果 x 是 s 的子串则返回 True 否则 返回 False |

#### 3.3.3 字符串处理函数

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| len(x) | 长度 | `len('你好') # 2` | 返回字符串的长度 |
| str(x) | 转换为字符串 | `str(123) # "123"` | 将任意类型转换为它的字符串形式 |
| hex(x)<br>oct(x) | 整数的十六进制小写形式字符串<br>整数的八进制小写形式字符串 | `hex(425) # "0x1a9"`<br>`oct(425) # "0c651"` |
| chr(u)<br>ord(x) | 将 Unicode 编码，转换为对应的字符串<br>将字符串，转换为对应 Unicode 编码 | | `u` 为 Unicode 编码<br>`x` 为 字符串 |

#### 3.3.4 字符串的处理方法

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| str.lower()<br> str.upper() | 将字符串转为小写<br>将字符串转为大写 | `"AbcDefG".lower() # abcdefg`<br>`"AbcDefG".upper() # ABCDEFG` |
| str.split(sep=None) | 切分字符串 | `"A,B,C".split(',') # ['A', 'B', 'C']` | 根据 `sep` 拆分字符串，返回一个列表 |
| str.count(sub) | 计数 | `"an apple a day".count('a') # 4` | 返回字符串 `sub` 在 str 中出现的次数 |
| str.replace(old, new) | 替换 | `"abcda".replace('a', 'e') # "ebcde"` | 使用 `new` 替换 `old` |
| str.center(width[, fillchar]) | 居中 | `"python".center(20, '=') # "=======python======="` | 输出的字符串总长度为 `width`，其余部分用 `fillchar` 填充并保存 `str` 居中 |
| str.strip(chars) | 去除头尾 | `"= python=".strip("=np") # "ytho"` | 去除 str 两边的字符（集） |
| str.join(iter) | 分隔 | `','.join("1234") # "1,2,3,4"` | 除最后一个字符外，将每一个字符后加一个 `str`（与大部分编程语言不同） |

#### 3.3.4 字符串的格式化

格式化是对字符串进行格式表的的方式

* 使用 `format()` 方法对字符串进行格式化 `<模版字符串>.format(<逗号分隔的参数>)`

```py
# 字符串格式化
"{0}：计算机{1}的CPU占用率为{2}%".format("2020-10-16", "C", 10)
# 2020-10-16：计算机C的CPU占用率为10%
```

槽内部对格式化的配置方式：`<参数序号>:<格式控制标记>`

格式控制标记

| : | <填充> | <对齐> | <宽度> | <,> | <精度> | <类型> |
|---|---|---|---|---|---|---|
| 引导符号 | 用于填充的单个符号 | < 左对齐<br>> 右对齐<br>^ 居中对齐 | 槽设定的输出宽度 | 数字的千分位分隔符 | 浮点数精度 或 字符串最大输出长度 | 整数类型 b c d o x<br>浮点数类型 e E f %

```py
# 由 = 填充，长度为 20，原字符串居中
"{0=^20}".format("PYTHON") # "=======PYTHON======="

# 由 * 填充，长度为 20，原字符串右对齐
"{0:*>20}".format("PYTHON") # "*******=======PYTHON"

# 由 (空格) 填充，长度为 10，原字符串左对齐
"{:10}".format("PYTHON") # "PYTHON    "

"{0:,.2f}".format(12345.6789) # 12,345.68
```

### 3.4 模块2: time 库的使用

time 库是 Python 中处理时间的标准库

* 计算机时间的表达
* 提供获取系统时间并格式化输出功能
* 通过系统级精确计时功能，可用于程序性能分析

```py
import time
time.<b>()
```

time 库包含三类函数

1. 时间获取：time() ctime() gmtime()
2. 时间格式化：strftime() strptime()
3. 程序计时：sleep() perf_counter()

**时间获取**

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| time() | 获取当前时间戳 | `time.time() # 1606812459.466781` | 返回计算机内部的时间值，浮点数（表示从1970年1月1日0:00开始到当前时刻的以秒为单位的数值）|
| ctime() | 获取当前时间 | `time.ctime() `<br>`# 'Tue Dec  1 16:50:37 2020'` | 以可读方式返回当前时间，字符串 |
| gmtime() | 获取当前时间 | `time.gmtime() # time.struct_time(tm_year=2020, tm_mon=12, tm_mday=1, tm_hour=8, tm_min=52, tm_sec=39, tm_wday=1, tm_yday=336, tm_isdst=0)` | 获取当前时间 struct_time 格式（`struct_time 格式` 是一种计算机可以处理的时间格式）|

**时间格式化**

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| strftime(tpl, ts) | 格式化时间 | `time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())`<br>`# '2020-12-01 08:59:24'` | `tpl` 格式化模版字符串，定义输出效果<br>`ts` 计算机内部时间类型变量 |
| strptime(str, tpl) | 将字符串转换为时间格式 | `time.strptime('2020-12-01 08:59:24', "%Y-%m-%d %H:%M:%S")`<br>`# time.struct_time(tm_year=2020, tm_mon=12, tm_mday=1, tm_hour=8, tm_min=59, tm_sec=24, tm_wday=1, tm_yday=336, tm_isdst=-1)` | `str` 字符串形式的时间值<br>`tpl` 格式化模版字符串，定义输入效果

**时间类型变量(ts)**

| 格式化字符串 | 描述 | 范围 | 示例 |
|:----:|-----|:-----:|-----|
| %a | 星期缩写 | Mon-Sun | `Wed` |
| %H | 小时（24h制）| 00-21 | `12` |
| %I | 小时（12h制）| 01-12 | `7` |
| %p | 上午/下午 | AM,PM | `PM` |
| %M | 分钟 | 00-59 | `26` |
| %S | 秒 | 00-59 | `30` |

**程序计时**：测量起止动作所经历的时间的过程

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| perf_counter() | 返回一个 CPU 级别精度的时间计数值 | `start = time.perf_counter() # 2128.24219297`<br>`end = time.perf_counter() # 2129.243051212`<br>`start - end # 1.0008582420000494` | 返回值以秒为单位，由于该方法计数值的起点不明确，多次调用取差值才有意义 |
| sleep(s) | 休眠 | `time.sleep(3.5) # 程序休眠 3.5 秒后再向后执行` | `s` 程序休眠时间，以秒为单位，可以是浮点数 |

### 3.5 实例4: 文本进度条

```py
# 文本进度条一
import time
scale = 10
print("------开始执行------")
for i in range(scale):
    a = '*' * i
    b = '.' * (scale - i)
    c = (i/scale) * 100
    print("{:^3.0f}%[{}->{}]".format(c, a, b))
    time.sleep(0.1)
print("------执行结束------")

# --------------执行结果----------------
------开始执行------
 0 %[->..........]
10 %[*->.........]
20 %[**->........]
30 %[***->.......]
40 %[****->......]
50 %[*****->.....]
60 %[******->....]
70 %[*******->...]
80 %[********->..]
90 %[*********->.]
------执行结束------
```

```py
# 文本进度条二 单行动态刷新
import time
for i in range(101):
    print("\r{:3}%".format(i), end="")
    time.sleep(0.1)
```

```py
# 文本进度条三 完整功能
import time
scale = 50
print("执行开始".center(scale//2, "-"))
start = time.perf_counter()
for i in range(scale+1):
    a = '*' * i
    b = '.' * (scale - i)
    c = (i/scale)*100
    dur = time.perf_counter() - start
    print("\r{:^3.0f}%[{}->{}]{:.2f}s".format(c,a,b,dur),end='')
    time.sleep(0.1)
print("\n"+"执行结束".center(scale//2,'-'))
```

进度条的设计函数

| 名称 | 趋势 | 函数 |
|:----:|:-----:|-----|
| Linear | Constant | `f(x) = x` |
| Early Pause | Speeds up | `f(x) = x+1-sin(x*π*2+π/2)/-8` |
| Late Pause | Slows Down | `f(x) = x+1-sin(x*π*2+π/2)/8` |
| Slow Wavy | Constant | `f(x) = x+sin(x*π*5)/20` |
| Fast Wavy | Constant | `f(x) = x+sin(x*π*20)/80` |
| Power | Speeds up | `f(x) = (x+(1-x)*0.03)^2` |
| Inverse Power | Slows Down | `f(x) = 1+(1-x)^1.5 *-1` |
| Fast Power | Speeds up | `f(x) = (x+(1-x)/2)^8` |
| Inverse Fast Power | Slows Down | `f(x) = 1+(1-x)^3 *-1` |

## 4. 程序的控制结构

> 掌握程序的控制逻辑，学会使用异常处理，掌握 random 库，具备应用随机数的能力。

### 4.1 程序的分支结构

**if elif else**

```py
# if elif else

if <条件1>:
    <语句快1> # 当 条件1 为 True 时执行
elif <条件2>:
    <语句快2> # 当 条件2 为 True 时执行
...
else:
    <语句快N> # 当以上条件均为 False 时执行
```

* elif 可以有多个也可以没有 elsif
* else 可以省略

**条件判断操作符**

| 操作符 | 数学符号 | 描述 |
|:-----:|:----:|-----|
| < | < | 小于 |
| <= | ≦ | 小于等于 |
| > | > | 大于 |
| > | ≧ | 大于等于 |
| == | = | 等于 |
| != | ≠ | 不等于 |

| 操作符 | 使用 | 描述 | 示例 | 备注 |
|:-----:|:----:|-----|-----|-----|
| and | x and y | 逻辑与 | `x and y` | 当 x, y 都为 True 时 返回 True，否则返回 False |
| or | x or y | 逻辑或 | `x or y` | 当 x, y 其中之一为 True 时 返回 True，否则返回 False |
| not | not x | 逻辑非 | `not x` | 当 x 为 True 返回 False<br>当 x 为 False 返回 True |

**异常处理**

```py
# 异常处理

# 第一种形式
try:
    <语句快1>
except:
    <语句快2>

# 第二种形式
try:
    <语句快1>
except <异常类型>: # 当标志异常类型后，仅处理相应类型的异常
    <语句快2>

# 第三种形式 高级用法
try:
    <语句快1>
except:
    <语句快2>
else: # 在不发生异常时执行
    <语句快3>
finally: # 不论是否发生异常 finally 语句快 均会执行
    <语句快4>
```

### 4.2 实例5: 身体质量指数 BMI

### 4.3 程序的循环结构

**for 循环**

```py
# for 循环
for <循环变量> in <遍历结构>:
    <循环体>
else: # 在循环结束时执行（因 break 而退出时不执行）
    <语句>

# 计数循环
# N 为循环次数
# 从 0 开始 到 N-1
for i in range(N):
    <循环体> # 执行 N 次

# 循环特定次
# 从 M 开始遍历到 N-1，步长为 K
for i in range(M, N, K):
    <循环体>
```

```py
for c in 'Python':
    print(c, end=",")
# P,y,t,h,o,n,

for item in [123, 'abc', 456]:
    print(item, end=",")
# 123,abc,456

# 计数循环
for i in range(3):
    print(i)
# 0
# 1
# 2

for i in range(2, 5):
    print(i)
# 2
# 3
# 4

for i in range(1, 5, 2):
    print(i)
# 1
# 3
```

**while 循环**

```py
# while 循环

# 知道 条件 为 False 时结束，否则一直执行 循环体
while <条件>:
    <循环体>
else: # 在循环结束时执行（因 break 而退出时不执行）
    <语句>
```

**循环保留字**

* `break` 跳出并结束整个循环，执行循环后的代码
* `continue` 结束当前循环，继续执行下一次循环

> `break` 和 `continue` 可在 for 循环和 while 循环中使用

### 4.4 模块3: random 库的使用

random 库是使用随机数的 Python 标准库

伪随机数：采用梅森旋转算法生成的（伪）随机序列中的元素

```py
# 使用 random 库
import random
```

基本随机函数

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| seed(a=None) | 初始化随机种子 | `random.seed(10) # 产生种子 10 的随机序列` | `a` 默认为当前系统的时间 |
| random() | 生成 [0.0, 1.0] 之间的随机小数 | `random.random()` | 

扩展随机函数

| 函数 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| randint(a, b) | 生成 [a, b] 之间的随机整数 | `random.randint(10, 80)` |
| randrange(m, n[, k]) | 生成一个 [m, n] 之间的以 k 为步长的随机整数 | `random.randrange(10, 100, 10)` |
| getrandbits(k) | 生成一个 k 比特长的随机整数 | `random.getrandbits(16)` |
| uniform(a, b) | 生成一个 [a, b] 之间的随机小数 | `random.uniform(10, 100)` |
| choice(seq) | 从序列 seq 中随机选择一个元素 | `random.choice([1,2,3,4,5,6,7,8,9])` |
| shuffle(seq) | 将序列 seq 中的元素随机打乱并返回 | `random.shuffle([1,2,3,4,5,6,7,8,9])` |

### 4.5 实例6: 圆周率的计算

```py
# 圆周率的计数

# 公式法
pi = 0
N = 100
for k in range(N):
    pi += 1/pow(16,k)*( \
              4/(8*k+1) - 2/(8*k+4) - \
              1/(8*k+5) - 1/(8*k+6) ) 
print("圆周率值是: {}".format(pi))

# 蒙特卡罗方法
from random import random
from time import perf_counter
DARTS = 1000*1000
hits = 0.0
start = perf_counter()
for i in range(1, DARTS+1):
    x, y = random(), random()
    dist = pow(x ** 2 + y ** 2, 0.5)
    if dist <= 1.0:
        hits = hits + 1
pi = 4 * (hits/DARTS)
print("圆周率值是: {}".format(pi))
print("运行时间是: {:.5f}s".format(perf_counter() - start))

```

## 5. 函数和代码复用

> 掌握函数的基本使用方法，理解并掌握递归使用，掌握 PyInstaller 库，能够编写带有函数的程序，并能够打包可执行文件。

### 5.1 函数的定义与使用

函数的理解

* 函数是一段具有特定功能，可复用的语句组
* 函数是一种功能抽象
* 作用：降低编程难道；代码复用

函数的定义

```py
# 函数的定义
def <函数名>(<参数（0个或多个）>):
    <函数体>
    return <返回值>

# 函数可以有参数，也可以没有参数，但括号不能省略
```

* 函数定义时，参数是一种占位符
* 函数定义时，参数是输入，函数体处理，返回值是输出（IPO）
* 函数定义后，如果未调用，则函数不会执行

函数的使用及调用过程

```py
# 函数的调用
<函数名>(<参数（与定义匹配）>)

<变量> = <函数名>(<参数（与定义匹配）>)
# <变量> 用于接收返回值
```

* 调用函数时给出实际参数
* 函数调用后得到返回值

函数的参数传递

* **可选参数** - 函数定义时可给予参数一个默认值，在调用时如果可以不传递该参数，则该参数为默认值，如果调用时传递了该参数，则默认值为调用时传递的值

```py
# 可选参数 函数的定义
def <函数名>(<参数1>,...,<参数N>=<默认值>):
    <函数体>
    return <返回值>

def add(a, b=1):
    result = a + b
    return result

add(1) # 2, a = 1, b = 1(默认值)
add(1, 2) # 3, a = 1, b = 2
```

* **可变参数** - 函数定义时可以设计可变的参数数量。可变参数在一个函数中只能有一项，并且必须放在最后一项。

```py
# 可变参数 函数的定义
def <函数名>(<参数1>,...,*<可变参数>):
    <函数体>
    return <返回值>

def add(*n):
    sum = 0
    for i in n:
        sum += i
    return sum

add(1, 2) # 3
add(1, 2, 3) # 6
```

参数传递的方式

* 按参数的位置传递
* 按参数的名称传递

```py
def add(a, b):
    result = a + b
    return result

# 按参数的位置传递
add(1, 2) # 3, a = 1, b = 2
# 按参数的名称传递
add(a = 1, b = 2) # 3, a = 1, b = 2
add(b = 1, a = 2) # 3, a = 2, b = 1
```

函数的返回值

* `return` 保留字用来传递返回值
* 函数可以有返回值，也可以没有
* `return` 可以返回 0 个或多个返回值

```py
def calculator(a, b):
    sum = a + b
    pro = a * b
    return sum,pro

calculator(2, 3) # (5, 6)
s,p = calculator(2, 3) # s = 5, p = 6
```

局部变量和全局变量

1. 局部变量和全局变量是不同的

* 局部变量是函数内部的占位符，局部变量可能和全局变量重名，但二者是不同的变量
* 函数调用完毕后，局部变量会被释放
* 可以使用 `global` 保留字在函数内使用全局变量

```py
s = 0 # s 是全局变量
def add(a, b):
    s = a + b # s 是局部变量
    return s # s 是局部变量
add(1, 2) # 2
# 全局变量 s 仍为 0
```

```py
s = 0 # s 是全局变量
def add(a, b):
    global s = a + b # s 是全局变量
    return s # s 是全局变量
add(1, 2) # 2
# 全局变量 s 为 2（在函数 add 内部被改变）
```

2. 局部变量为组合数据类型且未创建，等同于全局变量。对于剧本数据类型，无论是否重名，局部变量与全局变量始终是不同的

```py
ls = [ 'f', 'F' ] # ls 为全局变量
def appendLs():
    ls.append(a) # ls 未创建，等同于全局变量
    return

appendLs() # ls 被修改 [ 'f', 'F', 'a' ]
```

```py
ls = [ 'f', 'F' ] # ls 为全局变量
def appendLs():
    ls = []
    ls.append(a) # ls 创建了，为局部变量
    return

appendLs() # [ 'a' ]，全局变量 ls 仍为 [ 'f', 'F' ]
```

lambda 函数

* lambda 函数是一种匿名函数，即没有函数名的函数
* 使用 `lambda` 保留字定义，函数名是返回结果
* lambda 函数用于定义简单的、能够在一行内表示的函数

```py
# lambda 函数
<函数名> = lambda <参数>: <函数体>

# 等价于
def <函数名>(<参数>):
    <函数体>
    return <返回值>

add = lambda a, b: a + b
add(1, 2) # 3
```

### 5.2 实例7: 七段数码管绘制

```py
# 七段数码管版本一
import turtle
def drawLine(draw):   # 绘制单段数码管
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    turtle.right(90)
def drawDigit(digit): # 根据数字绘制七段数码管
    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup()
    turtle.fd(20) 
def drawDate(date):  # 获得要输出的数字
    for i in date:
        drawDigit(eval(i))  # 通过eval()函数将数字变为整数
def main():
    turtle.setup(800, 350, 200, 200)
    turtle.penup()
    turtle.fd(-300)
    turtle.pensize(5)
    drawDate('20181010')
    turtle.hideturtle()
    turtle.done()
main()
```

```py
# 七段数码管版本二
import turtle, time
def drawGap(): #绘制数码管间隔
    turtle.penup()
    turtle.fd(5)
def drawLine(draw):   #绘制单段数码管
    drawGap()
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    drawGap()
    turtle.right(90)
def drawDigit(d): #根据数字绘制七段数码管
    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if d in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup()
    turtle.fd(20)
def drawDate(date):
    turtle.pencolor("red")
    for i in date:
        if i == '-':
            turtle.write('年',font=("Arial", 18, "normal"))
            turtle.pencolor("green")
            turtle.fd(40)
        elif i == '=':
            turtle.write('月',font=("Arial", 18, "normal"))
            turtle.pencolor("blue")
            turtle.fd(40)
        elif i == '+':
            turtle.write('日',font=("Arial", 18, "normal"))
        else:
            drawDigit(eval(i))
def main():
    turtle.setup(800, 350, 200, 200)
    turtle.penup()
    turtle.fd(-350)
    turtle.pensize(5)
#    drawDate('2018-10=10+')
    drawDate(time.strftime('%Y-%m=%d+',time.gmtime()))
    turtle.hideturtle()
    turtle.done()
main()
```

### 5.3 代码复用与函数递归

代码复用与模块化设计

**代码复用**：代码抽象

* 代码资源化：程序代码是一种用来表达计算的“资源”
* 代码抽象化：使用函数等方式对代码赋予更高级别的定义
* 代码复用：代码的重复使用

> 函数 和 对象 是代码复用的两种主要形式

**模块化设计**

* 通过函数或对象封装将程序划分为模块及模块间的表达
* 具体包含：主程序、子程序和子程序间的关系

**高内聚、低耦合**

* **高内聚**：两个部分之间交流很多，无法独立存在
* **低耦合**：两个部分之间交流很少，可以独立存在
* 模块内部紧耦合，模块之间松耦合

函数递归：函数定义中调用函数自身

> 递归类似于数学中的归纳法

* 存在递归链条
* 有退出条件

### 5.4 模块4: PyInstaller 库的使用

> PyInstaller 为第三方库，使用前需先安装  
> 安装 PyInstaller: `pip install pyInstaller`

[PyInstaller](http://www.pyinstaller.org) 库可将 Python 源代码（.py）转换成无需源代码的可执行文件

PyInstaller 库的使用 `pyinstaller -F <文件名>.py`

### 5.5 实例8: 科赫雪花小包裹

```py
# 科赫曲线绘制源代码
import turtle
def koch(size, n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0, 60, -120, 60]:
           turtle.left(angle)
           koch(size/3, n-1)
def main():
    turtle.setup(800,400)
    turtle.penup()
    turtle.goto(-300, -50)
    turtle.pendown()
    turtle.pensize(2)
    koch(600,3)     # 0阶科赫曲线长度，阶数
    turtle.hideturtle()
main()
```

```py
# 科赫雪花绘制源代码
import turtle
def koch(size, n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0, 60, -120, 60]:
           turtle.left(angle)
           koch(size/3, n-1)
def main():
    turtle.setup(600,600)
    turtle.penup()
    turtle.goto(-200, 100)
    turtle.pendown()
    turtle.pensize(2)
    level = 3      # 3阶科赫雪花，阶数
    koch(400,level)     
    turtle.right(120)
    koch(400,level)
    turtle.right(120)
    koch(400,level)
    turtle.hideturtle()
main()
```

## 6. 组合数据类型

> 掌握组合数据类型（集合、元组、列表、字典）的使用方法，掌握 jieba 库，能够处理一组数据，并处理中文文本。

### 6.1 集合类型及操作

#### 6.1.1 集合类型定义

> 集合是多个元素的无序组合

* 集合类型与数学中的集合概念一致
* 集合元素是无序的，每个元素唯一，不存在相同元素
* 集合元素不可更改，不可食可变数据类型
* 集合用 `{}` 表示，元素间用逗号分隔
* 创建集合类型用 `{}`，或 `set()`

```py
# 建立集合

# 使用 {} 建立集合
A = { 'python', 123, ('python', 123) } # { 'python', 123, ('python', 123) }
B = { 'python', 123, 'python', 123 } # { 'python', 123 }

# 使用 set 建立集合
C = set("pypy123") # {'y', '2', '1', 'p', '3'}
```

#### 6.1.2 集合操作符

| 操作符 | 使用 | 描述 | 备注 |
|:-----:|:----:|-----|-----|
| `|` | `S | T` | 并集 | 返回一个新集合，新集合中包含 S 和 T 中的所有元素 |
| - | S - T | 差 | 返回一个新集合，新集合中包含在 S 但不再 T 中的元素 |
| & | S & T | 交集 | 返回一个新集合，新集合中包含同时在 S 和 T 中的元素 |
| ^ | S ^ T | 补集 | 返回一个新集合，新集合中包含 S 和 T 中非相同的元素（与 & 相反） |
| < 或 <= | 子集 | S < T 或 S <= T | 返回 True 或 False，判断 S 和 T 的子集关系 |
| > 或 >= | S > T 或 S >= T | 包含 | 返回 True 或 False，判断 S 和 T 的包含关系 |
| `|=` | `S |= T` | 并集 | 更新 S，包含 S 和 T 中的所有元素
| -= | S -= T | 差 | 更新 S，包含在 S 但不再 T 中的元素 |
| &= | S &= T | 交集 | 更新 S，包含同时在 S 和 T 中的元素 |
| ^= | S ^= T | 补集 | 更新 S，包含 S 和 T 中非相同的元素（与 &= 相反） |

```py
# 集合操作符

A = { 'a', 'b', 'c' }
B = { 'c', 'd', 'e' }

A | B # { 'a', 'b', 'c', 'd', 'e' }
A - B # { 'a', 'b' }
B - A # { 'd', 'e' }
A & B # { 'c' }
A ^ B # { 'a', 'b', 'd', 'e' }
```

#### 6.1.3 集合处理方法

| 函数 | 描述 | 备注 |
|:----:|-----|-----|
| S.add(x) | 添加元素 | 如果 x 未包含在集合 S 中，则将 x 添加到 S 中 |
| S.discard(x) | 移除元素 | 从 S 中移除元素 x |
| S.remove(x) | 移除元素 | 从 S 中移除元素 x，如果 x 不存在则抛出 KeyError 异常 |
| S.clear() | 清空集合 | 移除 S 中的所有元素 |
| S.pop() | 随机读取一个元素 | 随机读取一个元素，并将该元素从 S 中移除，如果 S 为空则产生 KeyError 异常 |
| S.copy() | 复制 | 返回集合 S 的一根副本 |
| len(S) | 长度 | 返回 S 的元素个数 |
| x in S | 包含 | x 包含在 S 中时返回 True，否则返回 False |
| x not in S | 不包含 | x 包含在 S 中时返回 False，否则返回 True（与 in 相反） |
| set(x) | 类型转换 | 将其它类型数据转换成集合类型

#### 6.1.4 集合类型应用

* 包含关系比较：`in`、`not in`、`<`、`<=`、`>`、`>=`
* 数据去重：集合类型无重复数据，可通过将其它数据类型转换成集合类型再转换回原有类型去重

```py
# 数据去重
lt = [ 'a', 'b', 'c', 'a']
s = set(lt) # { 'a', 'b', 'c' }
lt = list(s) # ['a', 'b', 'c']
```

### 6.2 序列类型及操作

#### 6.2.1 序列类型定义

> 序列是一维元素向量，元素类型可以不同

* 序列类型类似于数学元素序列
* 元素间由序号引导，通过下标访问序列的特定元素

序列是一个基本类型，它包括

1. 字符串类型
2. 元组类型
3. 列表类型

序列元素的索引（与字符串的字符索引相同）

| | | | | | |
|-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|反向递减序号：|-5|-4|-3|-2|-1|
|序列：|“Hello world”|3.1415|1024|(2,3)|["Python", 3]|
|正向递增序号：|0|1|2|3|4|

#### 6.2.2 序列操作符

| 操作符 | 使用 | 描述 | 备注 |
|:-----:|:----:|-----|-----|
| in | `x in s` | 包含 | 如果序列 s 中存在 x 则返回 True，否则返回 False |
| not in | `x not in s` | 不包含 | 如果序列 s 中不存在 x 则返回 True，否则返回 False（与 in 相反）|
| + | `s + t` | 连接 | 连接两个序列 |
| * | `s * n` 或 `n * s` | 复制 | 将序列 s 复制 n 次 |
| s[i] | - | 索引 | 返回 s 中的第 i 个元素（i 为元素的序号，从 0 开始）|
| s[i:j] 或 s[i:j:k] | - | 切片 | 返回序列 s 中第 i 到 j 以 k 为步长的元素序列 |

> 参考 [字符串类型及操作](#33-字符串类型及操作)

#### 6.2.3 序列处理函数及方法

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| len(s) | 长度（元素个数） | 返回序列的长度 |
| min(s) | 最小元素 | 返回序列 s 的最小元素，s 中的元素需可比较（与元素类型有关）|
| max(s) | 最大元素 | 返回序列 s 的最大元素，s 中的元素需可比较（与元素类型有关）|
| s.index(x) 或 s.index(x, i, j) | 索引 | 返回序列 s 从开始到j位置中第一次出现元素 x 的位置 |
| s.count(x) | 计数 | 序列 s 中出现 x 的总次数 |

#### 6.2.4 元组类型及操作

> 元组是一种序列类型，创建后就不能被修改

* 元组使用小括号 `()` 或 `tuple()` 创建，元素间用逗号`,` 分隔
* 可以使用或不实用小括号
* 元组中个元素类型可以不同，无长度限制
* 元组继承了序列类型的全部通用操作
* 元组创建后不能修改，因此没有特殊操作

```py
# 元组的定义
animals = 'cat', 'dog', 'tiger' # ('cat', 'dog', 'tiger')
t = ( #ff0000, 'green', animals ) # ( #ff0000, 'green', 'cat', 'dog', 'tiger' )

def func():
    return 1, 2
```

#### 6.2.5 列表类型及操作

> 列表是一种序列类型，创建后可以随意被修改

* 列表使用方括号 `[]` 或 `list()` 创建，元素间用逗号 `,` 分隔
* 列表中个元素类型可以不同，无长度限制

```py
# 列表的定义
animals = [ 'cat', 'dog', 'tiger']  # [ 'cat', 'dog', 'tiger']

lt = animas # [ 'cat', 'dog', 'tiger']

# 方括号真正创建列表，赋值只传递引用
```

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| ls[i] = x | 替换 | 替换列表 ls 的第 i 个元素为 x |
| ls[i:j:k] = lt | 切片替换 | 使用 lt 替换列表 ls 中第 i 到第 j 以 k 为步长的元素 |
| del ls[i] | 删除 | 删除列表 ls 中第 i 个元素 |
| del ls[i:j:k] | 切片删除 | 删除列表 ls 中第 i 到第 j 以 k 为步长的元素 |
| ls += lt | 相连 | 将列表 lt 增加到列表 ls 后 |
| ls *= n | 复制 | 将列表 ls 的元素复制 n 次 |
| ls.append(x) | 添加 | 在列表 ls 后添加一个元素 x |
| ls.clear() | 清空 | 清空列表 ls 中的所有元素 |
| ls.copy() | 复制 | 复制列表 ls 中的所有元素 |
| ls.insert(i, x) | 插入 | 在列表 ls 的 i 处插入元素 x |
| ls.pop(i) | 读取并删除 | 将列表 ls 中的第 i 个元素取出并将其删除 |
| ls.remove(x) | 移除 | 将列表 ls 中的出现的第一个 x 元素删除 |
| ls.reverse() | 反转 | 将列表 ls 中的元素反转排列 |

#### 6.2.6 序列类型应用场景

* 元组用于元素不改变的应用场景
* 列表用于更加灵活的场景，它是最常用的序列类型
* 序列的主要作用：表示一些有序数据，并操作它们

### 6.3 实例9: 基本统计值计算

```py
# 基本统计值计数
def getNum():       #获取用户不定长度的输入
    nums = []
    iNumStr = input("请输入数字(回车退出): ")
    while iNumStr != "":
        nums.append(eval(iNumStr))
        iNumStr = input("请输入数字(回车退出): ")
    return nums

def mean(numbers):  #计算平均值
    s = 0.0
    for num in numbers:
        s = s + num
    return s / len(numbers)

def dev(numbers, mean): #计算方差
    sdev = 0.0
    for num in numbers:
        sdev = sdev + (num - mean)**2
    return pow(sdev / (len(numbers)-1), 0.5)

def median(numbers):    #计算中位数
    sorted(numbers)
    size = len(numbers)
    if size % 2 == 0:
        med = (numbers[size//2-1] + numbers[size//2])/2
    else:
        med = numbers[size//2]
    return med

n =  getNum() #主体函数
m =  mean(n)
print("平均值:{},方差:{:.2},中位数:{}.".format(m, dev(n,m),median(n)))
```

### 6.4 字典类型及操作

> 映射：一种键（索引）和值（数据）的对应（键值对）  
> 序列类型的索引是 0-N，字典的索引由用户定义  

#### 6.4.1 字典类型定义

> 字典是映射的体现

* 字典是键值对的集合，键值对之间是无序的
* 字典采用大括号 `{}` 或 `dict()` 创建，键值对用冒号 `:` 表示；键值对之间用逗号 `,` 分隔

> 字典类型中，通过键获取值

```py
# 定义字典
<字典变量> = { <键1>:<值1>,<键2>:<值2>,...,<键n>:<值n> }
# 获取字典的值
<值> = <字典变量>[<键>]
# 更改或增加字典的值
<字典变量>[<键>] = <值>
```

#### 6.4.2 字典处理函数及方法

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| del d[k] | 删除 | 删除字典 d 中 k 对应的数据值 |
| x in d | 包含 | 如果序列 d 中存在 x 则返回 True，否则返回 False |
| len(d) | 长度 | 返回字典 d 的元素个数 |
| d.keys() | 获取健 | 返回字典 d 中的所有健的信息 |
| d.values() | 获取值 | 返回字典 d 中的所有值的信息 |
| d.items() | 获取键值对 | 返回字典 d 中的所有键值对的信息 |
| `d.get(k, <default>)` | 获取值 | 当 k 存在时，返回 k 对应的值，否则返回 `<default>` |
| `d.pop(k, <default>)` | 删除并获取值 | 当 k 存在时，删除并返回 k 对应的值，否则返回 `<default>` |
| d.popitem() | 删除并获取健值对 | 从字典 d 中随机删除并返回一个键值对，以元组形式返回 |
| d.clear() | 清空 | 删除所有键值对 |

遍历字典类型

```py
for k in d:
    <语句快>
```

#### 6.4.3 字典类型应用场景

* 与映射（键值对）相关的场景
* 主要作用：表达键值对数据，并操作它们

### 6.5 模块5: jieba 库的使用

jieba 最优秀的中文分词第三方库

安装：`pip install jieba`

### 6.6 实例10: 文本词频统计

## 7. 文件和数据格式化

> 掌握文件的使用方法，理解一二维数据，掌握 wordcloud 库，能够处理包含一二维数据的文件，能够用程序绘制词云。

> 文件是数据和抽象的集合

### 7.1 文件的使用

#### 7.1.1 文件的类型

* 文件是存储在辅助存储器上的数据序列
* 文件是数据存储的一种形式
* 文件展现形态：文本文件和二进制文件

文本文件 vs 二进制文件

* 文本文件和二进制文件只是文件的展示方式
* 本质上：所有文件都是二进制形式存储
* 形式上：所有文件采用两种方式展示

**文本文件** - 文本文件有唯一特定编码组成的文件，如 UTF-8 编码  
**二进制文件** - 直接由比特 0 和 1 组成，诶有统一字符编码

#### 7.1.2 文件的打开和关闭

文件的处理步骤：打开 - 操作 - 关闭

```py
# 文件的处理
a = open() # 打开文件
# 读文件
a.read(size)
a.readline(size)
a.readlines(hint)
# 写文件
a.write(size)
a.writelines(size)
a.seek(offset)
a.close() # 关闭文件
```

打开文件

```py
<变量名> = open(<文件路径和名称>, <打开模式>)
```

| 文件打开模式 | 描述 | 说明 |
|:----------:|-----|-----|
| r | 只读模式 | 默认值，如文件不存在则抛出错误 FileNotFoundError |
| w | 覆盖写模式 | 文件不存在则创建文件，文件存在则完全覆盖原文件 |
| x | 创建写模式 | 文件不存在则创建文件，文件存在则抛出错误 FileExistsError |
| a | 追加写模式 | 文件不存在则创建文件，文件存在则在文件最近追加内容 |
| b | 二进制文件模式 |
| t | 文本文件模式 | 默认值 |
| + | - |与 r/w/x/a 一同使用，在原功能基础上增加同时读写功能 |

> 文件打开模式可组合使用，如 rt、a+、wb 等

```py
# 打开文件

# 以文本形式打开文件
tf = open(fileName, 'rt')

# 二进制文件形式打开文件
bf = open(fileName, 'rb')
```

#### 7.1.3 文件内容读取

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| f.read(size=-1) | 读入全部内容 | 如果给出参数，读入前 size 长度 |
| f.readline(size=-1) | 读入一行内容 | 如果给出参数，读入该行前 size 长度 |
| f.readlines(hint=-1) | 读入文件所有行 | 以行为元素形成对象，如果给出参数，读入前 hint 行

```py
# 文件内容读取

# 遍历全文，方法一，一次读入，统一处理
f = open(fileName, 'r')
txt = f.read()
<文件处理>
f.close()

# 遍历全文，方法二，按数量读入，逐步处理
f = open(fileName, 'r')
txt = f.read(2)
while txt != '':
    <文件处理>
    txt = f.read(2)
f.close()

# 逐行遍历文件，方法一，一次读入，分行处理
f = open(fileName, 'r')
txt = f.read(2)
for line in f.readlines():
    <文件处理>
f.close()

# 逐行遍历文件，方法二，分行读入，逐步处理
f = open(fileName, 'r')
txt = f.read(2)
for line in f:
    <文件处理>
f.close()
```

#### 7.1.4 数据的文件写入

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| f.write(s) | 写入 | 向文件写入一个字符串或字符流 |
| f.writelines(lines) | 写入列表 | 将一个元素全为字符串的列表写入文件 |
| f.seek(offset) | 改变文件操作指针 | 改变当前文件操作的指针位置，offset 含义：`0` - 文件开头 `1` - 当前位置 `2` - 文件结尾 |

### 7.2 实例11: 自动轨迹绘制

```py
import turtle as t
t.title('自动轨迹绘制')
t.setup(800, 600, 0, 0)
t.pencolor("red")
t.pensize(5)
#数据读取
datals = []
f = open("data.txt")
for line in f:
    line = line.replace("\n","")
    datals.append(list(map(eval, line.split(","))))
f.close()
#自动绘制
for i in range(len(datals)):
    t.pencolor(datals[i][3],datals[i][4],datals[i][5])
    t.fd(datals[i][0])
    if datals[i][1]:
        t.rt(datals[i][2])
    else:
        t.lt(datals[i][2])
```

### 7.3 一维数据的格式化和处理

#### 7.3.1 数据组织的维度

> 一维数据：由对等关系的有序或无序数据构成，采用线性方式组织  
> 二维数据：由多个一维数据构成，是一维数据的组合形式  
> 多维数据：由一维或二维数据在新维度上的扩展  
> 高维数据：仅利用最基本的二元关系展示数据间的复杂结构  

数据的操作周期：存储 - 表示 - 操作

#### 7.3.2 一维数据的表示

如果数据间有序则使用列表类型

* 列表类型可以表达一维有序数据
* for 循环可以遍历数据，进而对每个数据进行处理

如果数据间无序则使用集合类型

* 集合类型可以表达一维无序数据
* for 循环可以遍历数据，进而对每个数据进行处理

#### 7.3.3 一维数据的存储

使用分隔符（空格、逗号（`,`），其它符号或符号组合（建议采用特殊符号））

* 使用一个或多个指定的分隔符进行存储，不换行
* 缺点：数据中不能存在指定的分隔符

#### 7.3.4 一维数据的处理

从分隔符分隔的文件中读写数据

```py
# 从分隔符分隔的文件中读写数据

# 读
f = open(fileName)
txt = f.read()
ls = txt.split('<分隔符>') # 默认为空格
f.close()

# 写
f = open(fileName)
txt = f.write('<分隔符>'.join(ls)) # ls 为元素全部为字符串的列表
f.close()
```

### 7.4 二维数据的格式化和处理

#### 7.4.1 二维数值的表示

* 二维列表可以表达二维数据
* 使用两层 for 循环遍历每个元素

一维数据：列表类型和集合类型

```py
[3, 4, 5, 6] # 数据间有序
{5, 3, 6, 7} # 数据间无序
```

二维数据：列表类型

```py
[
    [0, 1, 2]
    [3, 4, 5],
    [6, 7, 8]
]
```

#### 7.4.2 CSV 数据存储格式

> CSV - Comma Separated Values

* 国际通用的一二维数据存储格式（.csv）
* 每行一个一维数据，采用逗号（`,`）分隔，无空行
* 如果莫个数据缺失，逗号仍要保留
* 二维数据的表头可以作为数据存储

```csv
"Country Name","Country Code","Region","Income_Group",
"中国","CHN","东亚与太平洋地区（不包括高收入）","中高等收入国家",
```

数据来自：https://data.worldbank.org.cn/country/中国

#### 7.4.3 二维数据的存储

* 由程序决定是按行存储还是按列存储
* 一般索引习惯：`ls[row][column]` ,先列后行
* 一般外层列表每个元素都是一行，按行存储

#### 7.4.4 二维数据的处理

```py
# 二维数据的处理

# 从 CSV 文件中读入数据
f = open(fileName)
ls = []
for line in f:
    line = line.replace('\n', '')
    ls.append(line.split(','))
f.close()

# 向 CSV 文件中写入数据
f = open(fileName)
ls = []
for item in ls: # 要加入的二维列表
    f.write(','.join(item)+'\n')
f.close()
```

### 7.5 模块6: wordcloud 库的使用

wordcloud 第三方词云库

安装 `pip install wordcloud`

```py
# 常规矩形词云

import jieba
import wordcloud
f = open("新时代中国特色社会主义.txt", "r", encoding="utf-8")

t = f.read()
f.close()
ls = jieba.lcut(t)

txt = " ".join(ls)
w = wordcloud.WordCloud( \
    width = 1000, height = 700,\
    background_color = "white",
    font_path = "msyh.ttc"    
    )
w.generate(txt)
w.to_file("grwordcloud.png")
```

```py
# 不规则图形词云
import jieba
import wordcloud
from scipy.misc import imread
mask = imread("chinamap.jpg")
excludes = { }
f = open("新时代中国特色社会主义.txt", "r", encoding="utf-8")
t = f.read()
f.close()
ls = jieba.lcut(t)
txt = " ".join(ls)
w = wordcloud.WordCloud(\
    width = 1000, height = 700,\
    background_color = "white",
    font_path = "msyh.ttc", mask = mask
    )
w.generate(txt)
w.to_file("grwordcloudm.png")
下载附件
```

### 7.6 实例12: 政府工作报告词云

## 8. 程序设计方法学

> 理解 Python 程序设计思维，掌握扩展 Python 编程的基本方法，掌握 os 库，能够安装 Python 第三方库。

### 8.1 实例13: 体育竞技分析

```py
from random import random
def printIntro():
    print("这个程序模拟两个选手A和B的某种竞技比赛")
    print("程序运行需要A和B的能力值（以0到1之间的小数表示）")
def getInputs():
    a = eval(input("请输入选手A的能力值(0-1): "))
    b = eval(input("请输入选手B的能力值(0-1): "))
    n = eval(input("模拟比赛的场次: "))
    return a, b, n
def simNGames(n, probA, probB):
    winsA, winsB = 0, 0
    for i in range(n):
        scoreA, scoreB = simOneGame(probA, probB)
        if scoreA > scoreB:
            winsA += 1
        else:
            winsB += 1
    return winsA, winsB
def gameOver(a,b):
    return a==15 or b==15
def simOneGame(probA, probB):
    scoreA, scoreB = 0, 0
    serving = "A"
    while not gameOver(scoreA, scoreB):
        if serving == "A":
            if random() < probA:
                scoreA += 1
            else:
                serving="B"
        else:
            if random() < probB:
                scoreB += 1
            else:
                serving="A"
    return scoreA, scoreB
def printSummary(winsA, winsB):
    n = winsA + winsB
    print("竞技分析开始，共模拟{}场比赛".format(n))
    print("选手A获胜{}场比赛，占比{:0.1%}".format(winsA, winsA/n))
    print("选手B获胜{}场比赛，占比{:0.1%}".format(winsB, winsB/n))
def main():
    printIntro()
    probA, probB, n = getInputs()
    winsA, winsB = simNGames(n, probA, probB)
    printSummary(winsA, winsB)
main()
下载附件
```

### 8.2 Python 程序设计思维

计算思维与程序设计

计算思维（Computational Thinking），基于计算机的思维方式：抽象问题的计算方式，利用计算机自动化求解

### 8.3 Python 第三方库安装

Python 第三方库社区：[pypi](https://pypi.org)

pip 安装方法：

* 安装第三方库：`pip install <第三方库名>`
* 更新第三方库：`pip install -U <第三方库名>`
* 卸载第三方库：`pip uninstall <第三方库名>`
* 下载并不安装第三方库：`pip download <第三方库名>`
* 列举第三方库的详细信息：`pip show <第三方库名>`
* 搜索第三方库：`pip search <关键字>`
* 列出已安装的第三方库：`pip list`

集成安装方法：[Anaconda](https://www.continuum.io)

文件安装方法：https://www.lfd.uci.edu/~gohlke/pythonlibs/

### 8.4 模块7: os 库的使用

os 库是 Python 的标准库，包含路径操作、进程管理、环境参数等

**路径操作**：os.path - 处理文件路径及信息

```py
# 路径操作
import os.path
# 或
import os.path as op
```

| 函数和方法 | 描述 | 示例 | 备注 |
|:----:|-----|-----|-----|
| os.path.abspath(path) | 返回绝对路径 | `os.path.abspath('file.txt')`<br>`# C:\\Documents\\file.txt` | 返回 path 在当前系统中的绝对路径 |
| os.path.normpath(path) | 统一路径 | `os.path.normpath('C://Documents//file.txt')`<br>`# C:\\Documents\\file.txt` | 归一化 path 表示格式，使用 `\\` 分隔路径 |
| os.path.relpath(path) | 返回相对路径 | `os.path.relpath('C://Documents//file.txt')`<br>`# ..\\..\\..\\Documents\\file.txt` | 返回当前程序与文件之间的相对路径（relative path）|
| os.path.dirname(path) | 返回目录路径 | `os.path.dirname('C://Documents//file.txt')`<br>`# C://Documents` | 返回 path 所在目录的路径 |
| os.path.basename(path) | 返回文件名称 | `os.path.basename('C://Documents//file.txt')`<br>`# file.txt` | 返回 path 中最后的文件名称 |
| os.path.join(path, *paths) | 组合路径 | `os.path.join('c:/', 'Documents/file.txt')`<br>`# c:/Documents/file.txt` | 组合 path 与 *paths 返回一个路径字符串 |
| os.path.exists(path) | 判断路径是否存在 | - | 判断 path 对应的路径或文件是否存在，存在返回 True，不存在返回 False |
| os.path.isfile(path) | 判断文件是否存在 | - | 判断 path 对应的文件是否存在，存在返回 True，否则返回 False |
| os.path.isdir(path) | 判断目录是否存在 | - | 判断 path 对应的目录是否存在，存在返回 True，否则返回 False |
| os.path.getatime(path) | 上一次访问时间 | - | 返回文件或目录上一次的访问时间 |
| os.path.getmtime(paht) | 最近修改时间 | - | 返回文件或目录最近修改时间 |
| os.path.getctime(paht) | 创建时间 | - | 返回文件或目录创建时间 |
| os.path.getsize(path) | 返回文件大小 | - | 返回文件的大小（以字节为单位）|

**进程管理**：启动系统中其它程序

```py
# 进程管理
import os.system
# 或
import os.system as osys
```

`os.system(command)`

* 执行程序或命令
* Windows 系统中，返回 cmd 的调用信息

**环境参数**：获取系统软硬件信息等环境参数

| 函数和方法 | 描述 | 备注 |
|:----:|-----|-----|
| os.chdir(path) | 修改档期程序操作的路径 |
| os.getcwd() | 返回程序的当前路径 |
| os.getlogin() | 返回当前系统登陆用户名 |
| os.cup_count() | 返回当前系统的 CPU 核心数量 |
| os.urandom(n) | 返回 n 个字符长度的速记字符串 |

### 8.5 实例14: 第三方库安装脚本

| 库名 | 用途 | pip 安装指令 |
|:----:|----|-------------|
| NumPy | N 维数据表示和运算 |pip install numpy |
| SymPy | 数学符号计算工具 | pip install sympy |
| Pandas | 高效数据分析和计算 | pip install pandas |
| Scipy | 数学、科学和工程计算 | pip install scipy |
| Matplotlib | 二维数据可视化 | pip install matplotlib |
| Seaborn | 统计类数据可视化 | pip install seaborn |
| Mayavi | 三维科学数据可视化 | pip install mayavi |
| PIL | 图像处理 | pip install pillow |
| Scikit-Learn | 机器学习和数据挖掘 |pip install sklearn |
| Requests | HTTP 协议访问及网络爬虫 | pip install requests |
| Networkx | 复杂网络和图结构的建模和分析 | pip install networkx |
| Jieba | 中文分词 | pip install jieba |
| Wheel | Python 第三方库文件打包工具 | pip install wheel |
| PyInstaller | 打包 Python 源文件为可执行文件 | pip install pyinstaller |
| Django | Python 最流行的 Web 开发框架 | pip install django |
| Pyramid | 规模适中的 Web 应用框架 | pip install pyramid |
| Flask | 轻量级 Web 开发框架 | pip install flask |
| Beautiful Soup | HTML 和 XML 解析器 | pip install beautifulsoup4 |
| Scrapy | 网络爬虫框架 | pip install scrapy |
| pyspider | web 页面爬取系统 | pip install pyspider |
| Python-Goose | 提取文章类型 Web 页面 | pip install python-goose |
| PyPDF2 | PDF 文件内容提取及处理 | pip install pypdf2 |
| NLTX | 自然语言文本处理 | pip install nltx |
| Python-docx | 创建或更新 Microsoft Word 文件 | pip install python-docx |
| Scikit-learn | 机器学习方法工具集 | pip install scikit-learn |
| TensorFlow | 机器学习计算框架 | pip install tensorflow |
| NXNet | 基于神经网络的机器学习计算框架 | pip install nxnet |
| docopt | Python 命令行解析 | pip install docopt |
| Re | 正则表达式解析和处理 | Python 标准库 |
| WeRoBot | 微信机器人开发框架 |pip install werobot |
| aip | 百度 Ai 开发平台接口 | pip install aip |
| MyQR | 二维码（QR Code）生成 | pip install myqr |
| PyQt5 | 基于 Qt 的专业级GUI开发框架 | pip install pyqt5 |
| wxPython | 跨平台 GUI 开发框架 | pip install wxpython |
| PyGObject | 使用 GTX+ 开发 GUI | pip install pygobject |
| PyOpenGL | 多平台 OpenGL 开发接口 | pip install pyopengl |
| PyGame | 简单小游戏开发框架 | pip install pygame |
| Panda3D | 跨平台 3D 渲染和游戏开发 | pip install panda3d |
| cocos2d | 2D 游戏和图形界面交互式应用程序 | pip install cocos2d |
| VR Zero | VR 应用程序开发 | |
| pyovr | Oculus Rift 的 Python 开发接口 |
| Vizard | Python 通用 VR 开发引擎 |
| Quads | 图片迭代 |
| ascii_art | 将图片转换为 ASCII 艺术风格 |
| turtle | 海龟绘图体系 |


## 9. Python 计算生态概览

> 了解 Python 计算生态的宽度和广度，了解各领域重要计算生态的名字，体会编程之美。

### 9.1 从数据处理到人工智能

1. **数据表示**：采用合适的方式用程序表达数据
2. **数据清洗**：数据归一化、数据转换、异常处理
3. **数据统计**：数据的摘要理解，数量、分布、中位数等
4. **数据可视化**：直观展示数据内涵的方式
5. **数据挖掘**：从数据分析获得知识，产生数据外的价值
6. **人工智能**：数据、语言、图像、视觉等方面深度分析与决策

Python - 数据分析

Numpy 表达 N 维数组的基础第三方库
Pandas 

Python - 数据可视化

Python - 文本处理

Python - 机器学习

### 9.2 实例15: 霍兰德人格分析雷达图

```py
mport numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.rcParams['font.family']='SimHei'
radar_labels = np.array(['研究型(I)','艺术型(A)','社会型(S)',\
                         '企业型(E)','常规型(C)','现实型(R)']) #雷达标签
nAttr = 6
data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],
                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],
                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],
                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],
                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],
                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值
data_labels = ('艺术家', '实验员', '工程师', '推销员', '社会工作者','记事员')
angles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)
data = np.concatenate((data, [data[0]]))
angles = np.concatenate((angles, [angles[0]]))
fig = plt.figure(facecolor="white")
plt.subplot(111, polar=True)
plt.plot(angles,data,'o-', linewidth=1, alpha=0.2)
plt.fill(angles,data, alpha=0.25)
plt.thetagrids(angles*180/np.pi, radar_labels,frac = 1.2)
plt.figtext(0.52, 0.95, '霍兰德人格分析', ha='center', size=20)
legend = plt.legend(data_labels, loc=(0.94, 0.80), labelspacing=0.1)
plt.setp(legend.get_texts(), fontsize='large')
plt.grid(True)
plt.savefig('holland_radar.jpg')
plt.show()
```

### 9.3 实例16: 玫瑰花绘制

```py
import turtle as t
# 定义一个曲线绘制函数
def DegreeCurve(n, r, d=1):
    for i in range(n):
        t.left(d)
        t.circle(r, abs(d))
# 初始位置设定
s = 0.2 # size
t.setup(450*5*s, 750*5*s)
t.pencolor("black")
t.fillcolor("red")
t.speed(100)
t.penup()
t.goto(0, 900*s)
t.pendown()
# 绘制花朵形状
t.begin_fill()
t.circle(200*s,30)
DegreeCurve(60, 50*s)
t.circle(200*s,30)
DegreeCurve(4, 100*s)
t.circle(200*s,50)
DegreeCurve(50, 50*s)
t.circle(350*s,65)
DegreeCurve(40, 70*s)
t.circle(150*s,50)
DegreeCurve(20, 50*s, -1)
t.circle(400*s,60)
DegreeCurve(18, 50*s)
t.fd(250*s)
t.right(150)
t.circle(-500*s,12)
t.left(140)
t.circle(550*s,110)
t.left(27)
t.circle(650*s,100)
t.left(130)
t.circle(-300*s,20)
t.right(123)
t.circle(220*s,57)
t.end_fill()
# 绘制花枝形状
t.left(120)
t.fd(280*s)
t.left(115)
t.circle(300*s,33)
t.left(180)
t.circle(-300*s,33)
DegreeCurve(70, 225*s, -1)
t.circle(350*s,104)
t.left(90)
t.circle(200*s,105)
t.circle(-500*s,63)
t.penup()
t.goto(170*s,-30*s)
t.pendown()
t.left(160)
DegreeCurve(20, 2500*s)
DegreeCurve(220, 250*s, -1)
# 绘制一个绿色叶子
t.fillcolor('green')
t.penup()
t.goto(670*s,-180*s)
t.pendown()
t.right(140)
t.begin_fill()
t.circle(300*s,120)
t.left(60)
t.circle(300*s,120)
t.end_fill()
t.penup()
t.goto(180*s,-550*s)
t.pendown()
t.right(85)
t.circle(600*s,40)
# 绘制另一个绿色叶子
t.penup()
t.goto(-150*s,-1000*s)
t.pendown()
t.begin_fill()
t.rt(120)
t.circle(300*s,115)
t.left(75)
t.circle(300*s,100)
t.end_fill()
t.penup()
t.goto(430*s,-1070*s)
t.pendown()
t.right(30)
t.circle(-600*s,35)
t.done()
```

---

鸣谢：[Python 语言程序设计](https://www.icourse163.org/course/BIT-268001?tid=1460270441)

[0. 基本概念]: #0-基本概念

[1. Python 基本语法元素]: #1-python-基本语法元素
[1.1 程序设计基本方法]: #11-程序设计基本方法
[1.2 Python 开发环境配置]: #12-python-开发环境配置
[1.3 实例1: 温度转换]: #13-实例1-温度转换
[1.4 Python 程序语法元素分析]: #14-python-程序语法元素分析

[2. Python 基本图形绘制]: #2-python-基本图形绘制
[2.1 深入理解 Python 语言]: #21-深入理解-python-语言
[2.2 实例2: Python 蟒蛇绘制]: #22-实例2-python-蟒蛇绘制
[2.3 模块1: turtle 库的使用]: #23-模块1-turtle-库的使用
[2.4 turtle 程序语法元素分析]: #24-turtle-程序语法元素分析

[3. 基本数据类型]: #3-基本数据类型
[3.1 数字类型及操作]: #31-数字类型及操作
[3.2 实例3: 天天向上的力量]: #32-实例3-天天向上的力量
[3.3 字符串类型及操作]: #33-字符串类型及操作
[3.4 模块2: time 库的使用]: #34-模块2-time-库的使用
[3.5 实例4: 文本进度条]: #35-实例4-文本进度条

[4. 程序的控制结构]: #4-程序的控制结构
[4.1 程序的分支结构]: #41-程序的分支结构
[4.2 实例5: 身体质量指数 BMI]: #42-实例5-身体质量指数-bmi
[4.3 程序的循环结构]: #43-程序的循环结构
[4.4 模块3: random 库的使用]: #44-模块3-random-库的使用
[4.5 实例6: 圆周率的计算]: #45-实例6-圆周率的计算

[5. 函数和代码复用]: #5-函数和代码复用
[5.1 函数的定义与使用]: #51-函数的定义与使用
[5.2 实例7: 七段数码管绘制]: #52-实例7-七段数码管绘制
[5.3 代码复用与函数递归]: #53-代码复用与函数递归
[5.4 模块4: PyInstaller 库的使用]: #54-模块4-pyinstaller-库的使用
[5.5 实例8: 科赫雪花小包裹]: #55-实例8-科赫雪花小包裹

[6. 组合数据类型]: #6-组合数据类型
[6.1 集合类型及操作]: #61-集合类型及操作
[6.2 序列类型及操作]: #62-序列类型及操作
[6.3 实例9: 基本统计值计算]: #63-实例9-基本统计值计算
[6.4 字典类型及操作]: #64-字典类型及操作
[6.5 模块5: jieba 库的使用]: #65-模块5-jieba-库的使用
[6.6 实例10: 文本词频统计]: #66-实例10-文本词频统计

[7. 文件和数据格式化]: #7-文件和数据格式化
[7.1 文件的使用]: #71-文件的使用
[7.2 实例11: 自动轨迹绘制]: #72-实例11-自动轨迹绘制
[7.3 一维数据的格式化和处理]: #73-一维数据的格式化和处理
[7.4 二维数据的格式化和处理]: #74-二维数据的格式化和处理
[7.5 模块6: wordcloud 库的使用]: #75-模块6-wordcloud-库的使用
[7.6 实例12: 政府工作报告词云]: #76-实例12-政府工作报告词云

[8. 程序设计方法学]: #8-程序设计方法学
[8.1 实例13: 体育竞技分析]: #81-实例13-体育竞技分析
[8.2 Python 程序设计思维]: #82-python-程序设计思维
[8.3 Python 第三方库安装]: #83-python-第三方库安装
[8.4 模块7: os 库的使用]: #84-模块7-os-库的使用
[8.5 实例14: 第三方库安装脚本]: #85-实例14-第三方库安装脚本

[9. Python 计算生态概览]: #9-python-计算生态概览
[9.1 从数据处理到人工智能]: #91-从数据处理到人工智能
[9.2 实例15: 霍兰德人格分析雷达图]: #92-实例15-霍兰德人格分析雷达图

[保留字]: https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#keywords